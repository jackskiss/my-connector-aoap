##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// Re-implement these methods by overriding them in Impl$intf.name()$suffix.

#set($i = $intf.name())
#set($intfname = "$i$suffix")
#set($clname = "Base$intfname")
#if ($helper.isServer($mc))
#set($peer = "client")
#else
#set($peer = "server")
#end

#ifndef __$helper.getBaseName($intf, $mc).toUpperCase()_H__
\#define __$helper.getBaseName($intf, $mc).toUpperCase()_H__

\#include "$inc"

namespace $namespace {
  /**
   * Base implementation of $intfname, with default method implementations
   * which throw runtime_error. Extend this class to provide
   * implementations of messages from the $peer.
   *
   * @see Impl$intfname
   */

   class $clname
    : public $intfname
   {
#foreach ($mthd in $intf.iterator())
#if ($mthd.isMsgDir($mc) || $mthd.isMsgDirBoth())
#if (!$mthd.isHidden())
#if(!$methodList.contains($mthd.name().name()))
#set ( $addMethodListStatus = $methodList.add($mthd.name().name()) )
    public:
      $mthd.name()AsyncResultPtr $mthd.name()(#set( $sep = "" )#foreach($param in $mthd.iterator())$sep$helper.getEtchTypeName($param.type(), true) $param.name() #set( $sep = ", " )#end);
#end
#end
#end
#end

#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $m = $x.getModule() )
#set( $z = $m.iterator().next() )
#foreach( $n in $z.messages( true ) )
#if($n.isMsgDir($mc) || $n.isMsgDirBoth() )
#if(!$n.isHidden())
#if(!$methodList.contains($n.name().name()))
#set ( $addMethodListStatus = $methodList.add($n.name().name()) )
#if($n.isOneway())

    public:
      $n.name()AsyncResultPtr $n.name()(#set($sep = "")#foreach($p in $n.iterator())$sep$helper.getEtchTypeName($p.type(), true) $p.name() #set($sep = ", ")#end);
#else

    public:
      $n.name()AsyncResultPtr $n.name()(#set($sep = "")#foreach($p in $n.iterator())$sep$helper.getEtchTypeName($p.type(), true) $p.name() #set($sep = ", ")#end);
#end
#end
#end
#end
#end
#end
#end

   };
}
#endif /* $helper.getBaseName($intf, $mc).toUpperCase() */