##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

#set($i = $intf.name())
#set($vfname = "ValueFactory$i")
#set($intfname = "$i$suffix")
#set($clname = "Remote$intfname")

#ifndef __$helper.getRemoteName($intf, $mc).toUpperCase()_H__
\#define __$helper.getRemoteName($intf, $mc).toUpperCase()_H__

#if(!$hasBaseClass)
\#include "support/EtchRemoteBase.h"
#else
\#include "${vfname}.h"
\#include "$inc"
\#include "Remote${i}.h"
#end
\#include "${intfname}.h"
\#include "support/EtchAsyncResult.h"

namespace $namespace {
  /**
   * Call to message translator for $intfname.
   */
#if($hasBaseClass)
  class $clname : public Remote$i, public $intfname
#else
  class $clname : public EtchRemoteBase, public $intfname
#end
  {
  private:

    /**
     * Async result implementations of service methods.
     */

#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
    class $n.name()AsyncResultRemote : public #if($n.hasReturn())EtchAsyncResult<$helper.getEtchTypeName($n.type(), false)>#{else}EtchAsyncResultNone#end {
    public:
      /**
       * Create a new instance from $clname class
       */
      $n.name()AsyncResultRemote($clname* base, EtchMailbox* mailbox);

      /**
       * Destructor
       */
      virtual ~$n.name()AsyncResultRemote();

      /**
       * @see EtchNotify
       */
      status_t mailboxStatus(EtchMailbox* mb, EtchObject* state, capu::bool_t closed);

      /**
       * Create a new instance from $clname class
       */
       static $n.name()AsyncResultPtr Begin($clname* base#set($sep = ", ")#foreach($p in $n.iterator())$sep$helper.getEtchTypeName($p.type(), true) $p.name()#end);

    private:
        $clname* mBase;
    };

#end
#end
#end
  public:
    /**
     * Constructs the $clname.
     *
     * @param svc
     * @param vf
     * @param stack
     */
    $clname(EtchRuntime* runtime, EtchDeliveryService* svc, EtchValueFactory* vf, EtchStack* stack );
    
    /**
     * Destructor
     */
    virtual ~$clname();
  protected:
#if(!$hasBaseClass)
     EtchRuntime* mRuntime;
#end

  public:
#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc) || $n.isMsgDirBoth())
#if(!$n.isHidden())
#if(!$methodList.contains($n.name().name()))
#set ( $addMethodListStatus = $methodList.add($n.name().name()))
    $n.name()AsyncResultPtr $n.name()(#set( $sep = "" )#foreach( $p in $n.iterator() )$sep$helper.getEtchTypeName($p.type(), true) $p.name()#set( $sep = ", " )#end);
## TODO Implement delegate
## $n.name()AsyncResultPtr $n.name()(#set( $sep = "" )#foreach( $p in $n.iterator() )$sep$helper.getEtchTypeName($p.type(), true) $p.name()#set( $sep = ", " )#end${sep}EtchDelegate<$intfname::$n.name()AsyncResultPtr>* delegate);
#end
#end
#end
#end
##    //TODO: MIXIN generation!
###set( $k = 0 )
###foreach( $x in $intf.iterator() )
###if( $x.isMixin() )
##
##  // ----- mixin $x.name() ----- //
###set( $k = $k + 1 )
###set( $v = "_mixin$k" )
###set( $m = $x.getModule() )
###set( $z = $m.iterator().next() )
##
##  private final ${m.name()}.Remote$z.name()$suffix $v;
###foreach( $n in $z.messages( true ) )
###if($n.isMsgDir($mc))
###if(!$n.isHidden())
###if(!$methodList.contains($n.name().name()))
###set ( $addMethodListStatus = $methodList.add($n.name().name()) )
##  // --- generated methods for $n.name() --- //

###if($n.isOneway())
##  public final $helper.getTypeName( $n.type() ) $n.name()(
###set( $sep = "" )
###foreach( $p in $n.iterator() )
##    $sep$helper.getTypeName( $p.type() ) $p.name()
###set( $sep = ", " )
###end
##  )
##  {
##    ${v}.$n.name()(
###set( $sep = "" )
###foreach( $p in $n.iterator() )
##      $sep$p.name()
###set( $sep = ", " )
###end
##    );
##  }
###else
##  public final $helper.getTypeName( $n.type() ) $n.name()(
###set( $sep = "" )
###foreach( $p in $n.iterator() )
##    $sep$helper.getTypeName( $p.type() ) $p.name()
###set( $sep = ", " )
###end
##  )
###if($n.thrown().iterator().hasNext())
##  throws
###set( $sep = "" )
###foreach($t in $n.thrown().iterator())
##    $sep$t.getNamed().fqname()
###set( $sep = ", " )
###end
###end
##  {
###if($n.hasReturn())
##    return
###end
##    ${v}.$n.name()(
###set( $sep = "" )
###foreach( $p in $n.iterator() )
##      $sep$p.name()
###set( $sep = ", " )
###end
##    );
##  }
###end
###end
###end
###end
###end
###end
###end
  };
  typedef capu::SmartPointer<$clname> ${clname}Ptr;
}
#endif /* __$helper.getRemoteName($intf, $mc).toUpperCase()_H__ */